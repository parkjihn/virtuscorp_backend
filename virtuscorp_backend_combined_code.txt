# Directory: virtuscorp_backend

================================================================================

# Directory Structure

virtuscorp_backend
├── Dockerfile
├── app
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-312.pyc
│   │   └── config.cpython-312.pyc
│   ├── api
│   │   ├── __init__.py
│   │   ├── dependencies.py
│   │   └── routes
│   │       ├── __init__.py
│   │       ├── auth.py
│   │       ├── metrics.py
│   │       ├── reports.py
│   │       ├── user.py
│   │       └── yandex.py
│   ├── config.py
│   ├── crud
│   │   ├── __init__.py
│   │   ├── metric.py
│   │   ├── report.py
│   │   └── user.py
│   ├── db
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-312.pyc
│   │   │   └── database.cpython-312.pyc
│   │   └── database.py
│   ├── main.py
│   ├── middleware
│   │   └── cors.py
│   ├── models
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-312.pyc
│   │   │   ├── metric.cpython-312.pyc
│   │   │   ├── report.cpython-312.pyc
│   │   │   ├── user.cpython-312.pyc
│   │   │   └── yandex.cpython-312.pyc
│   │   ├── metric.py
│   │   ├── report.py
│   │   ├── user.py
│   │   └── yandex.py
│   ├── schemas
│   │   ├── __init__.py
│   │   ├── metric.py
│   │   ├── report.py
│   │   ├── user.py
│   │   └── yandex.py
│   ├── services
│   │   ├── __init__.py
│   │   ├── analysis.py
│   │   └── reporting.py
│   └── utils
│       ├── __init__.py
│       ├── helpers.py
│       └── logger.py
├── docker-compose.yml
├── entrypoint.sh
├── migrations
│   └── add_user_fields.py
├── pyproject.toml
├── requirements.txt
└── tests
    ├── __init__.py
    ├── test_auth.py
    ├── test_metrics.py
    └── test_reports.py

15 directories, 53 files

================================================================================

# requirements.txt

fastapi
uvicorn[standard]
asyncpg
tortoise-orm
aerich
pydantic[email]
passlib[bcrypt]
python-jose
axios
httpx
pandas
python-multipart
openpyxl
reportlab
sqlalchemy

================================================================================

# tests/__init__.py



================================================================================

# tests/test_auth.py



================================================================================

# tests/test_metrics.py



================================================================================

# tests/test_reports.py



================================================================================

# migrations/add_user_fields.py

"""
Migration script to add missing fields to the User table
"""
from tortoise import Tortoise, run_async
from app.config import get_database_url

async def run():
    # Connect to the database
    await Tortoise.init(
        db_url=get_database_url(),
        modules={"models": ["app.models.user"]}
    )
    
    # Get connection
    connection = Tortoise.get_connection("default")
    
    # Add missing columns to the User table
    # These columns are defined in the model but missing in the database
    await connection.execute_script("""
    ALTER TABLE "user" 
    ADD COLUMN IF NOT EXISTS position VARCHAR(255),
    ADD COLUMN IF NOT EXISTS department VARCHAR(255),
    ADD COLUMN IF NOT EXISTS phone VARCHAR(50),
    ADD COLUMN IF NOT EXISTS avatar_url VARCHAR(500),
    ADD COLUMN IF NOT EXISTS last_login TIMESTAMP;
    """)
    
    print("Migration completed successfully!")
    
    # Close connections
    await Tortoise.close_connections()

if __name__ == "__main__":
    run_async(run())


================================================================================

# app/__init__.py



================================================================================

# app/config.py

# app/config.py

import os


def get_database_url():
    try:
        with open("/run/secrets/db_password", "r") as f:
            password = f.read().strip()
    except FileNotFoundError:
        password = os.getenv("DB_PASSWORD", "")

    return f"postgres://postgres:{password}@db:5432/virtuscorp_db"


================================================================================

# app/main.py

from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from app.middleware.cors import add_cors_middleware
from app.api.routes import auth, yandex, metrics, reports, user
from tortoise.contrib.fastapi import register_tortoise
from app.db.database import TORTOISE_ORM
import os

app = FastAPI()

add_cors_middleware(app)

app.include_router(auth.router, prefix="/auth")
app.include_router(yandex.router, prefix="/api")
app.include_router(metrics.router, prefix="/api")  
app.include_router(reports.router, prefix="/api")
app.include_router(user.router, prefix="/api/user")

# Mount the uploads directory for serving static files
# Create the directory if it doesn't exist
uploads_dir = "uploads"
if not os.path.exists(uploads_dir):
    os.makedirs(uploads_dir)
    
app.mount("/uploads", StaticFiles(directory=uploads_dir), name="uploads")

# Create uploaded_files directory if it doesn't exist
uploaded_files_dir = "uploaded_files"
if not os.path.exists(uploaded_files_dir):
    os.makedirs(uploaded_files_dir)

# Create reports directory if it doesn't exist
reports_dir = "reports"
if not os.path.exists(reports_dir):
    os.makedirs(reports_dir)

register_tortoise(
    app,
    config=TORTOISE_ORM,
    generate_schemas=True,
    add_exception_handlers=True,
)


@app.get("/")
def read_root():
    return {"message": "Привет от FastAPI на проекте virtuscorp! nginx test"}


================================================================================

# app/utils/__init__.py



================================================================================

# app/utils/helpers.py

from datetime import datetime, timedelta, timezone
from jose import jwt, JWTError
from fastapi import Request, HTTPException
from app.models.user import User

SECRET_KEY = "12345"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

def create_access_token(data: dict, expires_delta=None):
    """
    Create a JWT access token with timezone-aware expiration.
    """
    to_encode = data.copy()
    # Use timezone-aware datetime objects
    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

async def get_current_user(request: Request) -> User:
    """
    Get the current user from the request token.
    """
    token = request.cookies.get("auth-token") or request.headers.get("x-auth-token")
    if not token:
        print("Authentication error: No token provided")
        raise HTTPException(status_code=401, detail="No token provided")

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email = payload.get("sub")
        if not email:
            print("Authentication error: Invalid token (no email in payload)")
            raise HTTPException(status_code=401, detail="Invalid token")

        user = await User.get_or_none(email=email)
        if not user:
            print(f"Authentication error: User not found for email: {email}")
            raise HTTPException(status_code=401, detail="User not found")
        
        print(f"Successfully authenticated user: {user.id} ({user.email})")
        return user
    except JWTError as e:
        print(f"JWT decode error: {str(e)}")
        raise HTTPException(status_code=401, detail="Invalid token")


================================================================================

# app/utils/logger.py



================================================================================

# app/schemas/__init__.py



================================================================================

# app/schemas/metric.py



================================================================================

# app/schemas/report.py

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class ReportBase(BaseModel):
    title: str
    report_type: Optional[str] = None
    filters_applied: Optional[str] = None
    export_format: Optional[str] = None

class ReportCreate(ReportBase):
    pass

class ReportResponse(ReportBase):
    id: int
    created_at: datetime
    status: str
    file_url: Optional[str] = None

    class Config:
        orm_mode = True

class ReportGenerateRequest(BaseModel):
    report_type: str
    date_range: Optional[str] = None
    filters: Optional[str] = None
    exclude_taxes: Optional[bool] = False
    show_profit_margin: Optional[bool] = False
    export_format: str = "pdf"
    file_naming: Optional[str] = None
    download_to_device: bool = True
    combine_reports: bool = False


================================================================================

# app/schemas/user.py

from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    email: EmailStr
    full_name: Optional[str] = None

class UserCreate(UserBase):
    password: str
    confirm_password: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserProfileUpdate(BaseModel):
    full_name: Optional[str] = None
    position: Optional[str] = None
    department: Optional[str] = None
    phone: Optional[str] = None
    avatar_url: Optional[str] = None

class UserProfileResponse(BaseModel):
    id: int
    email: EmailStr
    full_name: Optional[str] = None
    position: Optional[str] = None
    department: Optional[str] = None
    phone: Optional[str] = None
    avatar_url: Optional[str] = None
    last_login: Optional[datetime] = None
    
    class Config:
        orm_mode = True


================================================================================

# app/schemas/yandex.py

from pydantic import BaseModel

class YandexMarketCredentials(BaseModel):
    campaign_id: str
    business_id: str
    token: str


================================================================================

# app/services/__init__.py



================================================================================

# app/services/analysis.py



================================================================================

# app/services/reporting.py



================================================================================

# app/middleware/cors.py

from fastapi.middleware.cors import CORSMiddleware
from fastapi import FastAPI

def add_cors_middleware(app: FastAPI):
    origins = [
        "http://localhost:3000",
        "https://virtuscorp.site",
        "http://virtuscorp.site",
    ]

    app.add_middleware(
        CORSMiddleware,
        allow_origins=origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*", "x-auth-token"],
        expose_headers=["*", "Set-Cookie"]
    )

================================================================================

# app/crud/__init__.py



================================================================================

# app/crud/metric.py



================================================================================

# app/crud/report.py



================================================================================

# app/crud/user.py

from passlib.context import CryptContext
from app.models.user import User

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

async def get_user_by_email(email: str):
    return await User.get_or_none(email=email)

async def create_user(user_data):
    hashed_password = pwd_context.hash(user_data.password)
    return await User.create(
        full_name=user_data.full_name,
        email=user_data.email,
        password_hash=hashed_password,  # Changed from hashed_password to password_hash
    )


async def verify_user(email: str, password: str):
    user = await get_user_by_email(email)
    if user and pwd_context.verify(password, user.password_hash):  # Changed from hashed_password to password_hash
        return user
    return None


================================================================================

# app/db/__init__.py



================================================================================

# app/db/database.py

from app.config import get_database_url

TORTOISE_ORM = {
    "connections": {"default": get_database_url()},
    "apps": {
        "models": {
            "models": [
                "app.models.user",
                "app.models.metric",
                "app.models.report",
                "app.models.yandex",
                "aerich.models",
            ],
            "default_connection": "default",
        },
    },
}


================================================================================

# app/api/__init__.py



================================================================================

# app/api/dependencies.py



================================================================================

# app/api/routes/__init__.py



================================================================================

# app/api/routes/auth.py

# app/api/routes/auth.py - Optimized version

from fastapi import APIRouter, HTTPException, Response, Request
from fastapi.responses import JSONResponse
from app.schemas.user import UserCreate, UserLogin
from app.crud.user import create_user, verify_user, get_user_by_email
from app.utils.helpers import create_access_token
from app.models.user import User
from datetime import datetime, timezone
import logging

# Set up logging
logger = logging.getLogger(__name__)

router = APIRouter()


@router.post("/register")
async def register(user: UserCreate):
    if user.password != user.confirm_password:
        raise HTTPException(status_code=400, detail="Passwords do not match")

    existing = await get_user_by_email(user.email)
    if existing:
        raise HTTPException(status_code=400, detail="User already exists")

    new_user = await create_user(user)

    return {
        "message": "User registered successfully",
        "user": {
            "id": new_user.id,
            "full_name": new_user.full_name,
            "email": new_user.email,
        },
    }


@router.post("/login")
async def login(user: UserLogin, request: Request):
    try:
        # Verify the user against the database
        user_db = await verify_user(user.email, user.password)
        if not user_db:
            # Return 401 directly instead of raising an exception that gets caught later
            return JSONResponse(
                status_code=401, content={"detail": "Invalid credentials"}
            )

        # Update last login time - with error handling for missing column
        try:
            # Fix: Use timezone-aware datetime
            user_db.last_login = datetime.now(timezone.utc)
            await user_db.save()
        except Exception as e:
            # Log the error but don't fail the login process
            logger.warning(f"Could not update last_login: {str(e)}")

        # Generate token
        token = create_access_token({"sub": user_db.email})

        # Create response content
        content = {"message": "Login successful", "access_token": token}

        # Create response with proper cookie settings
        response = JSONResponse(content=content)

        # Set secure cookie - this is critical for authentication
        response.set_cookie(
            key="auth-token",
            value=token,
            httponly=True,  # Improves security
            secure=True,  # For HTTPS
            samesite="lax",  # Safer setting that works in most browsers
            path="/",
            max_age=86400,  # 24 hours - increased from 1 hour
        )

        return response

    except Exception as e:
        # Log errors
        logger.error(f"Login error: {str(e)}")
        # Return 500 error with details
        return JSONResponse(
            status_code=500, content={"detail": "Internal server error"}
        )


================================================================================

# app/api/routes/metrics.py

from fastapi import APIRouter, UploadFile, File, Depends, HTTPException
from app.utils.helpers import get_current_user
from app.models.user import User
import pandas as pd
import os
import glob
import traceback
from datetime import datetime, timezone
import json

router = APIRouter()
UPLOAD_DIR = "uploaded_files"
os.makedirs(UPLOAD_DIR, exist_ok=True)

@router.post("/upload-metrics")
async def upload_metrics_file(file: UploadFile = File(...), current_user: User = Depends(get_current_user)):
    """
    Upload a metrics file (CSV or Excel) for the current user.
    The file will be saved to the uploaded_files directory with a user-specific prefix.
    """
    # Validate file format
    if not file.filename.endswith((".csv", ".xlsx")):
        raise HTTPException(status_code=400, detail="Unsupported file format. Only CSV and Excel files are supported.")

    try:
        # Create a user-specific filename to avoid conflicts
        file_path = os.path.join(UPLOAD_DIR, f"user_{current_user.id}_{file.filename}")
        
        # Save the file
        with open(file_path, "wb") as f:
            f.write(await file.read())
        
        # Try to read the file to validate it
        try:
            if file.filename.endswith(".csv"):
                df = pd.read_csv(file_path)
            else:
                df = pd.read_excel(file_path)
            
            # Check if the file has data
            if df.empty:
                raise HTTPException(status_code=400, detail="The uploaded file is empty.")
            
            # Log success
            print(f"Successfully uploaded and validated file: {file_path}")
            print(f"File contains {len(df)} rows and {len(df.columns)} columns")
            print(f"Columns: {list(df.columns)}")
            
        except Exception as e:
            # If we can't read the file, it's probably invalid
            os.remove(file_path)  # Clean up the invalid file
            raise HTTPException(
                status_code=400, 
                detail=f"Invalid file format or content: {str(e)}"
            )
        
        return {"message": "File uploaded successfully", "filename": file.filename}
    
    except Exception as e:
        # Log the full error for debugging
        print(f"Error in upload_metrics_file: {str(e)}")
        traceback_str = traceback.format_exc()
        print(f"Traceback: {traceback_str}")
        
        # Return a user-friendly error
        raise HTTPException(
            status_code=500, 
            detail=f"Failed to upload file: {str(e)}"
        )

@router.get("/uploaded-data")
async def get_uploaded_data(current_user: User = Depends(get_current_user)):
    """
    Get the data from the most recently uploaded file for the current user.
    Returns the data as a list of records.
    """
    try:
        # Find all files uploaded by this user
        files = glob.glob(f"{UPLOAD_DIR}/user_{current_user.id}_*")
        
        if not files:
            # No files found, return empty data
            print(f"No files found for user {current_user.id}")
            return {"data": []}

        # Get the most recent file
        latest_file = max(files, key=os.path.getctime)
        
        # Debug information
        print(f"Reading file: {latest_file}")
        
        # Read the file based on its extension
        if latest_file.endswith(".csv"):
            df = pd.read_csv(latest_file)
        else:
            df = pd.read_excel(latest_file)
        
        # Convert DataFrame to records
        # Handle NaN values by replacing them with 0
        # Also convert all values to appropriate Python types
        records = []
        for _, row in df.iterrows():
            record = {}
            for col in df.columns:
                value = row[col]
                # Handle NaN, NaT, and None values
                if pd.isna(value):
                    record[col] = 0
                # Handle datetime objects
                elif isinstance(value, pd.Timestamp):
                    record[col] = value.strftime("%Y-%m-%d")
                # Handle other types
                else:
                    record[col] = value
            records.append(record)
        
        # Debug information
        print(f"Records count: {len(records)}")
        if len(records) > 0:
            print(f"First record keys: {list(records[0].keys())}")
            print(f"First record sample: {json.dumps(records[0], default=str)[:200]}...")
        
        return {"data": records}
    
    except Exception as e:
        # Print full traceback for debugging
        traceback_str = traceback.format_exc()
        print(f"Error in get_uploaded_data: {str(e)}")
        print(f"Traceback: {traceback_str}")
        
        # Return a more detailed error
        raise HTTPException(
            status_code=500, 
            detail=f"Failed to read file: {str(e)}. Please check file format and contents."
        )


================================================================================

# app/api/routes/reports.py

from typing import Any, Dict

from fastapi import APIRouter, Depends, HTTPException, Query, Response
from fastapi.responses import FileResponse
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.dependencies import get_db
from app.core.security import get_current_active_user
from app.models.user import User
from app.schemas.report import ReportCreate, ReportRead, ReportUpdate
from app.crud import crud_report
from app.utils.report_generator import generate_financial_report  # Example report generator
import os
import uuid
import traceback
from app.models.report import Report  # Import the Report model
from app.utils.helpers import get_current_user
from app.schemas.report import ReportResponse
from typing import List, Optional
import pandas as pd
import io
import json
from datetime import datetime, timezone
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
import tempfile
import glob

router = APIRouter()
UPLOAD_DIR = "uploaded_files"
REPORTS_DIR = "reports"
os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(REPORTS_DIR, exist_ok=True)

# Register a font with Cyrillic support
try:
    pdfmetrics.registerFont(TTFont('DejaVuSans', 'DejaVuSans.ttf'))
except Exception as e:
    print(f"Warning: Could not register DejaVuSans font: {str(e)}")
    # If the font is not found, we'll use the standard font


@router.post("/", response_model=ReportRead)
async def create_report(
    report_in: ReportCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
) -> Any:
    """
    Create a new report.
    """
    report_in.user_id = current_user.id
    report = await crud_report.report.create(db, obj_in=report_in)
    return report


@router.get("/{report_id}", response_model=ReportRead)
async def read_report(
    report_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
) -> Any:
    """
    Get a report by ID.
    """
    report = await crud_report.report.get(db, id=report_id)
    if not report:
        raise HTTPException(status_code=404, detail="Report not found")
    if report.user_id != current_user.id:
        raise HTTPException(status_code=400, detail="Not enough permissions")
    return report


@router.put("/{report_id}", response_model=ReportRead)
async def update_report(
    report_id: int,
    report_in: ReportUpdate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
) -> Any:
    """
    Update a report.
    """
    report = await crud_report.report.get(db, id=report_id)
    if not report:
        raise HTTPException(status_code=404, detail="Report not found")
    if report.user_id != current_user.id:
        raise HTTPException(status_code=400, detail="Not enough permissions")
    report = await crud_report.report.update(db, db_obj=report, obj_in=report_in)
    return report


@router.delete("/{report_id}", response_model=ReportRead)
async def delete_report(
    report_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
) -> Any:
    """
    Delete a report.
    """
    report = await crud_report.report.get(db, id=report_id)
    if not report:
        raise HTTPException(status_code=404, detail="Report not found")
    if report.user_id != current_user.id:
        raise HTTPException(status_code=400, detail="Not enough permissions")
    report = await crud_report.report.remove(db, id=report_id)
    return report


@router.get("/", response_model=list[ReportRead])
async def read_reports(
    db: AsyncSession = Depends(get_db),
    skip: int = Query(0, alias="offset"),
    limit: int = Query(10, alias="limit"),
    current_user: User = Depends(get_current_active_user),
) -> Any:
    """
    Get all reports for the current user.
    """
    reports = await crud_report.report.get_multi_by_owner(
        db, user_id=current_user.id, skip=skip, limit=limit
    )
    return reports


@router.post("/reports/generate", response_class=Response)
async def generate_report(
    report_data: dict,
    current_user: User = Depends(get_current_user)
):
    """
    Generate a report based on the uploaded data and the provided report configuration.
    Returns a PDF file.
    """
    try:
        # Log the current user information for debugging
        print(f"Report generation requested by user ID: {current_user.id}, email: {current_user.email}")
        print(f"Generating report with data: {json.dumps(report_data, default=str)}")
        
        # Find the latest uploaded file for the user
        files = glob.glob(f"{UPLOAD_DIR}/user_{current_user.id}_*")
        if not files:
            raise HTTPException(
                status_code=404, 
                detail="No data file found. Please upload a file on the 'Data Sources' page first."
            )
        
        latest_file = max(files, key=os.path.getctime)
        print(f"Using file: {latest_file}")
        
        # Read the data from the file
        try:
            if latest_file.endswith(".csv"):
                df = pd.read_csv(latest_file)
            else:
                df = pd.read_excel(latest_file)
            
            # Check if the DataFrame is empty
            if df.empty:
                raise HTTPException(
                    status_code=400, 
                    detail="The data file is empty. Please upload a file with data."
                )
            
            print(f"Data loaded successfully. Shape: {df.shape}")
        except Exception as e:
            print(f"Error reading data file: {str(e)}")
            traceback_str = traceback.format_exc()
            print(f"Traceback: {traceback_str}")
            raise HTTPException(
                status_code=500, 
                detail=f"Failed to read data file: {str(e)}"
            )
        
        # Apply filters from the request
        if report_data.get("exclude_taxes", False):
            # Example filtering - adapt to your data structure
            if "Налоги" in df.columns:
                df = df[df["Налоги"] == 0]
                print("Applied tax exclusion filter")
        
        # Create a PDF document
        buffer = io.BytesIO()
        
        # Set up styles
        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(
            'Title',
            parent=styles['Heading1'],
            fontName='DejaVuSans' if 'DejaVuSans' in pdfmetrics.getRegisteredFontNames() else 'Helvetica',
            fontSize=16,
            spaceAfter=12
        )
        
        normal_style = ParagraphStyle(
            'Normal',
            parent=styles['Normal'],
            fontName='DejaVuSans' if 'DejaVuSans' in pdfmetrics.getRegisteredFontNames() else 'Helvetica',
            fontSize=10
        )
        
        # Create the PDF document
        doc = SimpleDocTemplate(buffer, pagesize=letter)
        elements = []
        
        # Add title
        report_title = f"Отчет: {report_data.get('report_type', 'Финансовая сводка')}"
        elements.append(Paragraph(report_title, title_style))
        elements.append(Spacer(1, 12))
        
        # Add report metadata
        if report_data.get("date_range"):
            elements.append(Paragraph(f"Период: {report_data['date_range']}", normal_style))
        
        if report_data.get("filters"):
            elements.append(Paragraph(f"Фильтры: {report_data['filters']}", normal_style))
        
        elements.append(Spacer(1, 12))
        
        # Convert DataFrame to table for PDF
        # Get headers and data
        headers = df.columns.tolist()
        data = [headers]  # First row - headers
        
        # Add data rows
        for _, row in df.iterrows():
            data.append([str(x) for x in row.tolist()])
        
        # Create table
        table = Table(data)
        
        # Style the table
        table_style = TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.lightblue),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'DejaVuSans' if 'DejaVuSans' in pdfmetrics.getRegisteredFontNames() else 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ])
        
        table.setStyle(table_style)
        elements.append(table)
        
        # Build the PDF
        doc.build(elements)
        
        # Get the PDF data
        pdf_data = buffer.getvalue()
        buffer.close()
        
        # Generate filename and timestamp
        timestamp = datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')
        filename = f"{report_data.get('report_type', 'Report')}_{timestamp}.pdf"
        file_path = os.path.join(REPORTS_DIR, filename)
        
        # Save the PDF to disk
        with open(file_path, "wb") as f:
            f.write(pdf_data)
        
        # Create a record in the database for the generated report
        try:
            # Log the current user ID to verify it's being passed correctly
            print(f"Creating report with user ID: {current_user.id}")
            
            report = await Report.create(
                title=report_title,
                user=current_user,  # Pass the entire user object
                report_type=report_data.get("report_type", "financial"),
                status="completed",
                filters_applied=report_data.get("filters", ""),
                export_format=report_data.get("export_format", "pdf"),
                file_path=file_path
            )
            print(f"Created report record with ID: {report.id} for user ID: {current_user.id}")
        except Exception as e:
            print(f"Error creating report record: {str(e)}")
            traceback_str = traceback.format_exc()
            print(f"Traceback: {traceback_str}")
            # Continue even if the database record creation fails
        
        # Return the PDF file
        return Response(
            content=pdf_data,
            media_type="application/pdf",
            headers={
                "Content-Disposition": f'attachment; filename="{filename}"'
            }
        )
        
    except HTTPException as e:
        # Re-raise HTTP exceptions
        raise e
    except Exception as e:
        # Log the error
        print(f"Error generating report: {str(e)}")
        traceback_str = traceback.format_exc()
        print(f"Traceback: {traceback_str}")
        
        # Return a user-friendly error
        raise HTTPException(
            status_code=500, 
            detail=f"Error generating report: {str(e)}"
        )


================================================================================

# app/api/routes/user.py

from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
from app.models.user import User
from app.schemas.user import UserProfileUpdate, UserProfileResponse
from app.utils.helpers import get_current_user
import os
from datetime import datetime, timezone
import uuid
import shutil

router = APIRouter()

UPLOAD_DIR = "uploads/avatars"
os.makedirs(UPLOAD_DIR, exist_ok=True)

# Maximum file size (5MB)
MAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB in bytes

@router.get("/profile", response_model=UserProfileResponse)
async def get_user_profile(current_user: User = Depends(get_current_user)):
    """Get the current user's profile"""
    return {
        "id": current_user.id,
        "full_name": current_user.full_name,
        "email": current_user.email,
        "position": current_user.position,
        "department": current_user.department,
        "phone": current_user.phone,
        "avatar_url": current_user.avatar_url,
        "last_login": current_user.last_login
    }

@router.put("/profile", response_model=UserProfileResponse)
async def update_user_profile(
    profile_data: UserProfileUpdate,
    current_user: User = Depends(get_current_user)
):
    """Update the current user's profile"""
    # Update only the fields that are provided
    if profile_data.full_name is not None:
        current_user.full_name = profile_data.full_name
    if profile_data.position is not None:
        current_user.position = profile_data.position
    if profile_data.department is not None:
        current_user.department = profile_data.department
    if profile_data.phone is not None:
        current_user.phone = profile_data.phone
    if profile_data.avatar_url is not None:
        current_user.avatar_url = profile_data.avatar_url
    
    # Fix: Use timezone-aware datetime for last_login
    current_user.last_login = datetime.now(timezone.utc)
    
    await current_user.save()
    
    return {
        "id": current_user.id,
        "full_name": current_user.full_name,
        "email": current_user.email,
        "position": current_user.position,
        "department": current_user.department,
        "phone": current_user.phone,
        "avatar_url": current_user.avatar_url,
        "last_login": current_user.last_login
    }

@router.post("/avatar", response_model=dict)
async def upload_avatar(
    avatar: UploadFile = File(...),
    current_user: User = Depends(get_current_user)
):
    """Upload a new avatar for the current user"""
    # Validate file type
    allowed_types = ["image/jpeg", "image/png", "image/gif", "image/webp"]
    if avatar.content_type not in allowed_types:
        raise HTTPException(
            status_code=400,
            detail="Invalid file type. Only JPEG, PNG, GIF, and WebP are allowed."
        )
    
    # Check file size
    contents = await avatar.read()
    if len(contents) > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=400,
            detail=f"File size exceeds the limit of {MAX_FILE_SIZE / (1024 * 1024)}MB."
        )
    
    # Reset file position to start
    await avatar.seek(0)
    
    # Generate a unique filename
    file_ext = os.path.splitext(avatar.filename)[1]
    unique_filename = f"{uuid.uuid4()}{file_ext}"
    file_path = os.path.join(UPLOAD_DIR, unique_filename)
    
    # Save the file
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(avatar.file, buffer)
    
    # Update the user's avatar_url
    avatar_url = f"/uploads/avatars/{unique_filename}"
    current_user.avatar_url = avatar_url
    await current_user.save()
    
    return {"avatar_url": avatar_url}


================================================================================

# app/api/routes/yandex.py

from fastapi import APIRouter, Depends, HTTPException
from app.schemas.yandex import YandexMarketCredentials
from app.models.yandex import YandexIntegration
from app.models.user import User
from app.utils.helpers import get_current_user
import httpx

router = APIRouter()

@router.post("/yandex-market/save")
async def save_yandex_creds(
    creds: YandexMarketCredentials,
    current_user: User = Depends(get_current_user),
):
    existing = await YandexIntegration.get_or_none(user=current_user)
    if existing:
        existing.campaign_id = creds.campaign_id
        existing.business_id = creds.business_id
        existing.token = creds.token
        await existing.save()
    else:
        await YandexIntegration.create(
            user=current_user,
            campaign_id=creds.campaign_id,
            business_id=creds.business_id,
            token=creds.token,
        )

    return {"message": "Yandex credentials saved"}

@router.post("/yandex-market/test")
async def test_yandex_connection(
    creds: YandexMarketCredentials,
    current_user: User = Depends(get_current_user),
):
    url = f"https://api.partner.market.yandex.ru/campaigns/{creds.campaign_id}/stats"
    headers = {
        "Authorization": f"Bearer {creds.token}",
        "Accept": "application/json"
    }

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers)

        if response.status_code == 200:
            return {"success": True}
        return {"success": False, "detail": response.text}
    except Exception as e:
        return {"success": False, "detail": str(e)}


================================================================================

# app/models/__init__.py



================================================================================

# app/models/metric.py

from tortoise import fields
from tortoise.models import Model
from app.models.user import User


class Metric(Model):
    id = fields.IntField(pk=True)
    name = fields.CharField(max_length=255)  # Название метрики, например "Объем продаж"
    value = fields.FloatField()              # Значение метрики
    timestamp = fields.DatetimeField(auto_now_add=True)  # Когда зафиксировано значение
    user = fields.ForeignKeyField("models.User", related_name="metrics")  # Кто загрузил метрику
    marketplace = fields.CharField(max_length=100, null=True)  # Ozon, WB, Yandex и т.п.
    category = fields.CharField(max_length=100, null=True)     # например, "Продажи", "Ценообразование"

    class Meta:
        table = "metrics"

    def __str__(self):
        return f"{self.name}: {self.value} ({self.timestamp})"


================================================================================

# app/models/report.py

from tortoise import fields
from tortoise.models import Model
from datetime import datetime, timezone

class Report(Model):
    id = fields.IntField(pk=True)
    title = fields.CharField(max_length=255)
    user = fields.ForeignKeyField("models.User", related_name="reports")
    created_at = fields.DatetimeField(auto_now_add=True)
    report_type = fields.CharField(max_length=50, default="financial")  # financial, sales, inventory, marketing
    status = fields.CharField(max_length=20, default="completed")  # completed, in-progress, failed
    filters_applied = fields.TextField(default="")
    export_format = fields.CharField(max_length=10, default="pdf")  # pdf, excel, csv, json
    file_path = fields.CharField(max_length=255, null=True)  # Path to the saved report file
    
    class Meta:
        table = "reports"
    
    def __str__(self):
        return f"{self.title} ({self.created_at})"


================================================================================

# app/models/user.py

from tortoise import fields
from tortoise.models import Model
from datetime import datetime, timezone

class User(Model):
    id = fields.IntField(pk=True)
    email = fields.CharField(max_length=255, unique=True)
    password_hash = fields.CharField(max_length=255)  # This field name is correct
    full_name = fields.CharField(max_length=255, null=True)
    position = fields.CharField(max_length=100, null=True)
    department = fields.CharField(max_length=100, null=True)
    phone = fields.CharField(max_length=20, null=True)
    avatar_url = fields.CharField(max_length=255, null=True)
    last_login = fields.DatetimeField(null=True)
    created_at = fields.DatetimeField(auto_now_add=True)
    
    class Meta:
        table = "users"
    
    def __str__(self):
        return f"{self.email}"


================================================================================

# app/models/yandex.py

from tortoise import fields
from tortoise.models import Model
from app.models.user import User

class YandexIntegration(Model):
    id = fields.IntField(pk=True)
    user = fields.ForeignKeyField("models.User", related_name="yandex_integrations")
    campaign_id = fields.CharField(max_length=50)
    business_id = fields.CharField(max_length=50)
    token = fields.TextField()

    class Meta:
        table = "yandex_integrations"

    def __str__(self):
        return f"Yandex for {self.user.email}"



================================================================================
